---
// Loader.astro
---

<div id="loader" class="loader">

  <svg class="loader__image" viewBox="0 0 48 47" fill="none" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMid meet">
    <path d="M31.2817 13.5478L42.1955 8.50565L48 22.3584L36.8776 27.2609L44.8023 37.2579L33.1586 46.6093L24 35.0247L14.8414 46.6093L3.30195 37.3625L11.4352 27.3656L0 22.3584L6.11729 8.50565L16.701 13.3384L16.5967 0.829102H31.386L31.2817 13.5478Z" stroke="#fff" stroke-width="1" fill="none" vector-effect="non-scaling-stroke"/>
  </svg>
  
</div>

<script>
  import { waitForCriticalImages } from '../scripts/utils/images-ready.js';
  import gsap from 'gsap';

  // Wait for fonts and critical images to load before removing loader
  async function initLoader() {
    const loader = document.getElementById('loader');
    if (!loader) return;

    const startTime = Date.now();
    const minDisplayTime = 900; // 1.5 segundos m√≠nimo total

    try {
      // Wait for fonts
      await new Promise<void>((resolve) => {
        const handleFontsReady = () => {
          resolve();
        };
        
        window.addEventListener('fontsReady', handleFontsReady, { once: true });
        
        // Fallback for fonts
        document.fonts.ready.then(() => {
          setTimeout(() => {
            if (!(window as any).fontsReadyDispatched) {
              resolve();
            }
          }, 100);
        });
      });
      
      // Wait for critical images
      await new Promise<void>((resolve) => {
        waitForCriticalImages(() => {
          resolve();
        });
      });
      
      // Additional wait to ensure everything is fully rendered
      await new Promise(resolve => setTimeout(resolve, 200));
      
      // Calculate remaining time to ensure minimum display time
      const elapsed = Date.now() - startTime;
      const remaining = Math.max(0, minDisplayTime - elapsed);
      
      // Wait for remaining time if needed
      if (remaining > 0) {
        await new Promise(resolve => setTimeout(resolve, remaining));
      }
      
      // Get loader image
      const loaderImage = document.querySelector('.loader__image') as HTMLElement;
      
      // Mark that assets are ready and dispatch custom events
      (window as any).fontsReadyDispatched = true;
      window.dispatchEvent(new CustomEvent('fontsReady'));
      window.dispatchEvent(new CustomEvent('assetsReady'));
      
      // Animate image exit (up and out, no scale)
      if (loaderImage) {
        gsap.to(loaderImage, {
          y: '-100vh',
          opacity: 0,
          duration: .3,
          ease: 'power3.inOut',
        });
      }
      
      // Animate loader exit as curtain going up
      gsap.to(loader, {
        clipPath: 'inset(0 0 100% 0)', // Reveal from bottom (curtain going up)
        duration: .75,
        ease: 'power3.inOut',
        onComplete: () => {
          // Dispatch event when loader animation completes
          window.dispatchEvent(new CustomEvent('loaderComplete'));
          loader.remove();
        }
      });
      
    } catch (error) {
      console.warn('Asset loading error:', error);
      // Even if there's an error, ensure minimum display time
      const elapsed = Date.now() - startTime;
      const remaining = Math.max(0, minDisplayTime - elapsed);
      
      setTimeout(() => {
        (window as any).fontsReadyDispatched = true;
        window.dispatchEvent(new CustomEvent('fontsReady'));
        window.dispatchEvent(new CustomEvent('assetsReady'));
        
        // Animate image exit
        const loaderImage = document.querySelector('.loader__image') as HTMLElement;
        if (loaderImage) {
          gsap.to(loaderImage, {
            y: '-100vh',
            opacity: 0,
            duration: .4,
            ease: 'power3.inOut',
          });
        }
        
        // Animate loader exit as curtain going up
        gsap.to(loader, {
          clipPath: 'inset(0 0 100% 0)',
          duration: 1,
          ease: 'power3.inOut',
          onComplete: () => {
            window.dispatchEvent(new CustomEvent('loaderComplete'));
            loader.remove();
          }
        });
      }, remaining);
    }
  }

  // Initialize loader image rotation
  function initLoaderImageRotation() {
    const loaderImage = document.querySelector('.loader__image') as HTMLElement;
    if (loaderImage) {
      gsap.to(loaderImage, {
        rotation: 360,
        duration: 8, // Slower rotation
        ease: 'none',
        repeat: -1,
      });
    }
  }

  // Initialize loader when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      initLoaderImageRotation();
      initLoader();
    });
  } else {
    initLoaderImageRotation();
    initLoader();
  }
</script>
 

<style>
  .loader {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: #032746;
  color: #fff;
  display: flex;
  align-items: flex-end;
  overflow: hidden;
  clip-path: inset(0 0 0 0); /* Initial state - fully visible */
  will-change: clip-path;
  z-index: 9999;
}

.loader__image {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 120vh;
  height: 120vh;
  opacity: 0.15;
  z-index: 10;
  will-change: transform, opacity;
}

</style>